2002.2 update

この文書は，おまけ，ていうか，暇なときに気が向いたまま書き貯めたものです．

■■ XFireworks 開発秘話

XFireworks は X 上で動作する花火プログラムである．そもそもなんで XFireworks を
作ったかというと，単なる思いつきである．nadar-b05 を作り上げ，しばらく
ぼーっとしていた時期に，なにかまた作りたいなーと思っているとき，
電車の中で思いついた．
XFireworks を作りはじめたのは 2000 年の７月初旬だったのだが，nadar-b05 を
作ったときの教訓で，

	とりあえず動くものを作って公開しちまえ

というのがあったので，かなり早い段階でβ版を公開して linux-users-ML などで
広報し，あとは３日に１回ほど最新版をアップデートしながら作成していった．

結局それから１ヵ月くらいで書き上げ，８月のはじめに最終版をリリースしたので，
XFireworks は

	まさに季節もの

となり，なかなか評判がよかったようだ．雑誌にもいくつか取り上げられた．
XFireworks ができたのはちょうど花火大会まっさかりの時期だったので，
忙しくて花火大会に行かなかった友人に紹介したりしたのだが，

	夜に見てるとさみしい気分になる

と言われてしまったのがかなしいところだ．作者自身，よく電車の中や昼休みに
ぼーっと見ていたりしたのだが，はたから見たら，

	ちょっとノイローゼ気味なのだろうか

などと心配されてしまいそうである．単に作者自身は自分で作ったものを見て，

	悦に入っているだけ

だったのだが．

この文書はあまり技術的なことは書いてないのだけれど，たまには技術的なことでも
書こう．

XFireworks はC言語でのオブジェクト指向な書き方が自分なりに身についてきた頃に
書いた作品なので，ソースはとても(不満な点もいくつか残ってはいるが，
それはそれとして，他のぼくのプログラムに比べたらはるかに)すっきりしている．
X でのプログラミングがだいたいわかってきたころに書いたというのも
よかったのだろう．おかげで他のぼくのプログラムにはありがちな，

	「これはいつか直さなきゃならんなあ」

とかならまだましだが，

	「これはひどい，ひどすぎる」

とか，とんでもないのになると，

	「ちょっとこれは正視に耐えない」

といったようなところもあまりないのがお気に入りの１作である．ちなみに正視に
耐えないのは xstarroll である．次が xmangekyou かな．

XFireworks は作りはじめて，１週間くらいでとりあえず動作するプロトタイプが
できあがった．が，とにかく遅かった．花火が爆発するのが，

	しゅわしゅわしゅわ...

というように見えてしまうくらい遅かったのである．そこで，考えつく限りの
チューニングを行なっていくことになる．

原因は花火のカケラをひとつひとつ描画していたために X サーバに出すリクエストが
ボトルネックになっていたためだった．これを解決するために，描画をまとめて行なう
ようにリクエストを変更した．しかしまだ遅い．どうやら描画のたびに色を
確保していて，これもまた X サーバにリクエストを出すためにボトルネックに
なっているらしい．そこで，起動時に前もって色をすべて確保するようにした．
これでだいぶ速くなったのだが，今度は起動に時間がかかるようになってしまった．
Libretto で起動すると，起動に１分以上かかってしまうのである．原因は起動時の
色の確保で，毎回 X サーバに色を確保しにいってしまうことにあったので，
独自の色のデータベースを作成し，一度確保した色は使いまわすようにした．これで
まただいぶ速くなったがまだ遅い．データベース作成時に，すでに確保している
色かどうかのデータベースの検索に時間がかかっていたのだ．そこで検索処理に
キャッシュやハッシュを使うようにした．これで多少速くなったのだが
まだ遅いのである．と，一気に書いてしまったが，ここまでたどり着くのに
くりかえし何度も何度も試行錯誤した．

実際のプログラミングはほとんど Libretto で行なっている．ぼくの使っている
Libretto は Libretto SS1000 というやつで，片道１時間半の電車通勤中に

	電車の中でプログラムを書いて過ごすために

入社直前に購入したものだ．しかし，買ったときに

	すでにオールドモデルだった

このため，XFireworks を書いていた時点ではかなり遅いマシンだったのだが，
そのような遅いマシン(ちなみにこの文章を書いている2002年１月現在で，
まだ現役まる３年である)でもちゃんと動作するようにしたかったため，可能な限り
速くしたかったのだ．

調べてみると，ハッシュ関数があまり乱数的でないために１部分に集中してしまい，

	ぜんぜんハッシュになっていなかった

という恥ずかしいバグがあったことがわかったので，ハッシュ関数を書き直した．
さらに，ハッシュのチューニングを行なった．ハッシュの良いところは，サイズを
自由に調整することによって，メモリサイズと速度のトレードオフを自由に調整
できるところだ．これでだいぶ速くなった．

この他にも，sin(), cos() をデータベース化してしまうとか，一度使った
オブジェクトを削除せずにフリーリストにつないでおいて再利用することで
malloc() の回数を減らすとか，配列はまとめて確保して malloc() の回数を減らす
とか，など，考えつくかぎりのチューニングを行なった．
このように考えつく高速化をすべて行なった結果，XFireworks はかなり速く
動作するようになった．現在の速いマシンでは十分すぎるくらい速く動作するため，
今となってはそれほどありがたみも無いのだが，やはり

	高速化は，男の夢

とでもいうのだろうか．しかし，最近の速いマシンで動かすとさくさく動きすぎて，

	情緒もへったくれもない

といったところがかなしいところではある．

ただ，まだチューニングできる部分もある．そのうちのひとつとして，
起動時の色確保で，色のデータベースはハッシュ＆キャッシュ化しているために
高速なのだが，色の名前の文字列のデータベースはふつうの線形検索になっている．
ハッシュ＆キャッシュ用のクラスをもっと一般化して，一般的なオブジェクトを
扱えるようにして，色の名前もハッシュ＆キャッシュ化すれば，起動がもうちょっと
速くなるかもしれない．でもめんどくさいのでいいや．

うーん，ひさびさに技術的なことを書いてしまった．

2002/1
(次回作の OMAKE.jpn に続く)

■■ WonX 開発秘話

そもそもなんで WonderWitch をはじめたかというと，会社の先輩に紹介されたのだ．
その先輩もどうやらモノづくりの好きな人らしく，モノづくり大好き人間どうし
ということで，そのへんは，

	同じ血を感じる (坂井がかってに感じてるだけ)

とでも言うのだろうか，なにかおもしろいネタがあったら振ってほしいと
酒の席で冗談混じりに頼んでいたのだが，そのあとで WonderWitch を紹介された．

実際に購入したのは８月になってからだったのだが，いじってみると
昔のモノ作りの楽しさ，というか，コンピュータをいじる楽しさがぎゅうぎゅうに
詰まったようなもので，すぐにのめりこんだ．

ここで知らない人のために，WonderWitch というものについて，簡単に説明しよう．

バンダイから WonderSwan という携帯用ゲーム機が出ているが，この WonderSwan 上で
動作するプログラムを作るためのキットが WonderWitch である．株式会社 Qute が
開発した．
プログラム作成の手順は簡単で，Windows 環境でC言語で作成・コンパイルし，
WonderSwan には専用のカートリッジを装着して，専用の転送ケーブルと
転送ソフトを使って WonderSwan 側に転送すると，カートリッジに保存されて，
ゲームができる，といったぐあいである．
プログラム自体はゲームに限らず，アイディア次第でいろいろ書ける．
シリアルポートがあるので，応用範囲はとても広い．

ただ，C言語とはいっても当然C言語ができれば即プログラムが書けるという
ものではない．画面まわりやキー入力用の独自のサービス関数がいっぱい用意
されていて，それを使って書くことになるのだが，WonderSwan のハードウエアは
さすがゲーム機，というか，スプライト機能やパレット機能を持っているので，

	昔のMSXの時代は普通だったが，今となっては特殊な

ハードウエアである．つまり，スプライトとかパレットとかをちゃんと理解
できてないと，プログラムは書けないし，メモリの制限もあるし，
プログラムサイズの制限もあるし，言語がCになったというだけで，実はその中身は，

	昔の MSX とかでの BASIC プログラミングによく似てる

というのが正しい表現だと思う．

というわけではじめてみた WonderWitch なんだけど，ぼくの場合はもともと
BASIC や MS-C のような制限された環境で書いていたこともあるので，
あまり違和感無くのめり込めた．
ただぼくの場合は，

	プログラムの９割は通勤電車の中で書く

という「電車プログラマ」状態なので，コーディングの最中はいいのだが，
デバッグの段階になると，

	シリアルカードとシリアルケーブルと WonderSwan を常備して，
	電車の中でコンパイルして転送してテストする．

ということになってしまう．(実話)
まあ，ぼくが毎日乗っている電車は，朝は１車両に一人しか乗ってない
ということもザラで，

	電車の中で靴を脱いで足を伸ばしてプログラムを書く

ということも可能なくらい(さすがにここまではやってないけど)なので，
これでもべつにいいんだけれど，持ちものはなるべく軽くしたいと思っているので，
なんとかしたいと思っていた．

というわけで，WonderWitch の各種関数の互換関数を FreeBSD 用に作成して，
FreeBSD 上でコンパイル・リンク・実行が行えて，最低限のデバッグを
FreeBSD 上でできたらいいな，と思って作りはじめたのが WonX である．
しかし，やっているうちに，

	いつのまにか興味が逆転してしまった

で，WonX 作るのが目的になってしまった．

WonX 作っていて一番困ったのはなにかというと，技術的にどうとか
MS-DOS と UNIX の差がどうとかではない．ホントに一番困ったのは，
WonXってどんなものなのかを

	人に説明すること

である．
わかる人には，

	WonderWitch 用のプログラムを UNIX 上でコンパイル・リンクして，
	X 上で実行できる実行形式を作成するための互換ライブラリ

といっただけで，どんなものかだいたい理解してもらえる．しかし，わからない
人には，いくら説明してもわからないものだ．

2000年末から2001年初頭にかけて開催された，WonderWitch プログラミング
コンテスト(WWGP)に出品して，見事予選を通過して，本選に出場してきたのだが，
友人にそのことを説明(自慢)しようにも，

「こんど，プログラムコンテストで予選通過したので，発表してくるんよ」
「へー．なにを作ったの？」
「えーと，WonderSwan のプログラムを作るための WonderWitch っていうキットが
  あって，WonderWitch用のプログラムを...」(以下，必死に説明)
「？？？」
「うーん，つまり，プログラムを書くのを手伝うプログラム」

こんな説明しかできないのは，うーん，残念である．

(次回作の OMAKE.jpn に続く)

■■ N.A.D.A.R. 開発秘話

N.A.D.A.R. は，そもそもは中学生のときに，「TANK」という名前で作った，
２人対戦のゲームだった．もう10年以上前の話だ．

もともとぼくは戦車ゲームが好きなのだが，まわりにはあまり満足のいく
戦車ゲームが無かった．そこで昔のプログラマの鉄則，

	ほしければ作る

にしたがって，自宅の PC-9801VX で作ったのがはじまりだった．
このころ学校の理科室に PC-9801M2 があって，それでプレイしてたりしてた．
しかし当時の PC-9801M2 はすでにひと昔前の機種であり，8086 の 5MHz では
名機 PC-9801VX の 80286 8MHz にはかなうはずもなく，

	おそすぎてゲームにならん

とフトドキなことを考えていた．とくに接近戦になって，２人が同時に
砲弾とミサイルを撃つと，目に見えて速度が低下してしまう．しかしこれも，

	クライマックスでスローモーションになる，映画のワンシーンみたい

とあるていど納得していたわけであるから，

	遅延まで考慮に入れて逆に利用したゲーム

という，今思うとカッコイイ仕様ではあったと思う．(本当か!?)

TANK は一人プレイ用の TANK2，２人プレイ用になって，TANK3A，
改良を加えて，TANK3B, TANK3C, ... と製作していき，最終的には，
TANK3E まで製作した．
その後，兄の「戦車をもっと大きくしたほうがよい」という意見を採り入れて，
戦車を拡大した TANK3F，再びもとに戻した TANK3G というように，

	暇をみてはバージョンアップしていく

という，まさに趣味で作ってるプログラムであった．

大学３年生から４年生にかけて，

	マイコン BASIC MAGAZINE

によく投稿していて，一時期，常連になっていたのだが，
大学４年のときに，マイコン BASIC MAGAZINE の投稿用に，プログラムを
全体的に見直して，TANK3I を作った．が，これは，

	あえなくボツ

マイコン BASIC MAGAZINE の掲載基準は「アイディア重視」であって，
やはりこういうありがちなゲームは載りにくい．しかも２人でないと
プレイできないとなると，なおさら載りにくい．

ピーピング形式にして，TANK3J を作ったが，

	これもボツ

PC-9801 用の TANK は，ここまでである．

しかし，研究室に入って，X を使うようになってからは，いつか TANK を
X に移植したいと思っていた．そして，

	フリーソフトとして公開する

という，Tank 復活の方法を考えていた．

実際に Tank を書きはじめたのは，就職した1999年の4月からである．
4月に就職し，5月くらいから，Tank で使用するためのネットワーク通信用
ライブラリを書き出した．
このころ，ちょうど，

	オブジェクト指向

にはまってて，頭の中ではすっかりオブジェクト指向至上主義．

	オブジェクト指向で書いておけば，
	その向こうにはバラ色の世界が待っている

という考えだった．
しかし，通信には文字列処理がつきものなので，そのまえに文字列処理用の
String クラスを作ろう，と思った．
また，通信するには select() で調べることが必要になるから，select() 用の
クラスも欲しい．ソケットの接続までの部分は接続部分として，別クラスにしたい．
通信は文字列の通信を行う部分と，じっさいにデータ通信を行う部分は別クラスに
したい，などという感じで，オブジェクト指向をやりたてのときにありがちな，

	なんでもかんでもクラスにしよう

というようにはまってしまい，あげくのはてには，

	単なる整数までも，Integer クラスで管理しそうな勢い

になって，収拾がつかなくなってしまう．
また，クライアントが複数になったときには，サーバ側では fork() して通信の
接続要求だけを処理するようなプロセスを作って，クライアントごとには
通信だけを処理するプロセスを作り，サーバプロセスとはパイプで通信する...
というような実装も見越した上で書きたい，などと，

	はてしない深みにはまっていってしまった

そのうち EyeClock-2.0 の開発を始めることになってしまい，こっちに
どっぷりつかってしまった．
1999年の８月から12月にかけては，EyeClock-2.0 にかかりっきりで，
Tank は先送り(ていうか，ほとんど忘れ去られた状態)になってしまった．

EyeClock-2.0 は1999年の年末ぎりぎり(クリスマスイブだった．
とくに意味はないのだが)に公開した．しかし今思えば，

	クリスマスイブに，世のため人のために

フリーソフトを公開しているなんて，

	聖人のような生活

だと思ってしまう．
しかし，ただの時計なので，

	たいして世のためになっていない

というのが悲しいところである．

EyeClock-2.0 がひと段落してからは，あそびで XKeyWrap とかを書いていたのだが，
2000年の１月中旬くらいにようやく Tank を書き出した．
以前の教訓があったので，今回はあまり細部にこだわらずに，

	とりあえず動くもんをつくって公開しちまえ

という方針で開発を進めた．
以前のネットワーク用ライブラリとか，EyeClock-2.0 での経験とかが
あったので，開発はトントン拍子に進んで，わずか１ヵ月足らずで
ふつうにプレイできるプロトタイプが仕上がった．

よく，「N.A.D.A.R.って，なんの略なの？」と聞かれる．
N.A.D.A.R. の命名には，ずいぶん悩んだ．ここで，命名の由来を書こう．

もともと橋本も僕も，

	グロブダー

というゲームが好きだった．ナムコのずいぶん古いアーケードゲームなのだが，
ちょっとでも気を抜いたら(ていうか，気を抜いていなくても)，あっと言うまに
やられてしまうという，スリルとスピード感のあるゲームだった．

やはりスリルと緊張感，一瞬の判断こそが

	アクションゲームの醍醐味

だとぼくは思っているので，そんなゲームを作りたいと常々思っていた．

N.A.D.A.R. のプロトタイプが完成して，そろそろ名前を決めてしまいたいと
いうとき，橋本と焼肉屋に行った．で，焼肉屋でいろいろ話したのだが，とりあえず，

	「TANK」はやめよう

ということになった．また，

	「エックスなんちゃら」という名前もやめよう

ということになった．

戦車の重みを表現したいので，「グロブダー」のように，濁音のある名前にしたい．
そう考えると，「グロブダー」は，G,B,D と，濁音のある文字が３つも入っている．
そこで考えたのが，

	GNOMEDAR

でも，GNOME は直接的にとくに関係は無いのでこれは却下．
いっそのこと，日本的な名前はどうだろう？

	「風林火山」

なんて冗談半分でいろいろ考えていたのだが，そこでそのとき，

	「灘の生一本」

という日本酒のポスターが目に入った．

	「灘」ってのはどうだ？

このときは，あまり深く考えてなくって，けっきょくこの日には決まらなかった
のだが，このときにしっかり決めなかったのがよくなかった．
そのうち開発を進めるうちに，ファイル名とかドキュメントとかも整理しだして，

	ほんとにもういいかげん名前を決めたい

と思い，けっきょく，「灘」にアクセントで r をつけて，「NADAR」にしてしまった．

というように，あまり意味なく決まってしまった「NADAR」なのだが，
作者としては，いちおう，

	アルファベットになにか意味を持たせたい

うーん，

	N.A.D.A.R. - Network Action ...

だめだ，Dのあたりでなんにもおもいつかん．

(次回作の OMAKE.jpn に続く)

■■ EyeClock 開発秘話

そもそもなんで EyeClock を作り出したかってはなし．

大学の卒業研究のために研究室に配属されたのは，1996年の３月だった．
この研究室では数値計算を行うため，メインの OS として UNIX が使われていた
のだが，僕にとっては，これが，よかった．

研究室では主に FreeBSD を使って作業していたんだけれど，

	「好きな画像を時計にしたい!」

と，常々思っていた．
今思えば，よく探せばそういう時計アプリケーションもなにかしらあるんじゃ
ないかと思うんだけど，そのときはよく探しもせずに，man xclock をてきとーに
読んだくらいであきらめていた．
これが後々 EyeClock の開発につながったわけだ．

EyeClock の開発に着手したのは，たしか，1998 年の６月ごろだったと思う．

1998年の５月というと，自分は大学院の修士２年で，就職活動のあいまを
見つけては，本業の研究をそっちのけにして，

	XMangekyou

を書いていた．
なにせこのころは，毎日毎日，一日中 X のプログラミングをしてたのだ．
毎週火曜と水曜には研究室に泊まって，大学の近くの

	三河屋という酒屋(理科大の人はよく知っているハズだ)

に行って，ビールとワインを買って，夜になると，

	飲んで歌いながら

プログラミングをしていたもんだ．(今考えると，不気味だ)
研究室にはスパゲッティとミートソースの缶詰を買い置き(これも三河屋で買ったもの)
してあって，だいたい夜の12時を過ぎたころに，夜食を食べて，で，
明け方の4時頃までがんばって，眠くてどうしようもなくなったら，寝袋で寝る．
朝は10時頃に起きて，大学のトレーニングルームでシャワーを浴びて，
シャンプーして，ヒゲをそって，で，またプログラミングを始める，
といった生活だった．
このため，研究室には，

	着替えも常備してあった

このころまでは，だれも使っていなかった Sun SPARC Station 5 をよく
使っていたんだけれど，XMangekyou の動作を XFree86 上でテストする
必要性が出てきたので，これまたあまりだれも使っていなかった，ロースペックの
オーダーメイド AT 互換機(FreeBSD + XFree86) を使うようになった．
このロースペックマシンは，研究室に数少ない，

	音の出るマシン

のうちのひとつだったので，けっこうお気に入りだった．ロースペックなので，
だれも使わないし，計算を走らせたりもしないから，気軽に使えるということもあり，
けっきょく，卒業するまで，ずっとこのマシンを使っていた．
EyeClock や XStarRoll や修士論文は，すべてこのマシンを使って書いた．

５月の中旬に就職が決まって，そのあとには，たまに研究もしつつ，
でも本業はプログラミングというくらいのいきおいで，プログラミングをしていた．
当時の後輩曰く，

	「坂井さんはいっつも研究室にいるけど，
	  なにをやっているのかわからんです」

研究してるわけでもないし，遊んでいるようにも見えないし，ということだった
らしい．とはいっても，

	じつは遊んでいたんだけどね

５月の終り頃，XMangekyou をひととおり作り終えたあとは，いよいよ EyeClock の
開発にとりかかる．

まず，時計「MyClock」を作った．これは，時計とはいっても，

	白黒のビットマップを張りつけられるだけ

という，非常におそまつなものだった．当時はまだピックスマップファイルの
読み込みかたをしらなかったので，しかたなくビットマップで作ったのだ．

このあたりの作業の順番はじつはうろおぼえなので，たしかなことはよく
覚えていないのだが，次にやったのは，

	「ピックスマップファイルを読み込んで，カラーで表示したい!」

ということだったとおもう．
しかし，X の標準では，ピックスマップファイルを読み込んでピックスマップを
作成するような関数は，提供されていない．
X や Motif の書籍をいろいろ調べたのだが，ピックスマップファイルの
読み込みかたは，書いていなかった．そこで，かの有名な，

	EmiClock

のソースを参考にすることにした．
EmiClock のソースを読んで，はじめて Xpm ライブラリの存在を知り，
ピックスマップファイルを読み込むことができるようになった．
ちなみに EmiClock はすばらしく優れたプログラムで，ソースを見ると
わかるのだが，ほんとにいたれりつくせりで，

	X のプログラミングをしようとしてるひとは，ぜひ読んだほうがいい

という，おすすめの１本である．

これで MyClock は，カラーの画像が扱えるようになった．自分としては
それなりに満足して，タレントの画像を張り付けたりして使っていた．
そんなある日，忘れもしない，帰宅中の

	三田線水道橋〜白山

あたりで，ふと思った．

	「あれで目を動かしたら，面白いんじゃないか？」

ここから EyeClock の開発が始まったわけだ．

(次回作の OMAKE.jpn に続く)

■■ 趣味のプログラム

ぼくは子供のころから，なにかものを作ることが趣味だったんだけど，
ある日，ぼくの兄上(こいつもなにかものを作ることが趣味なのだが)と，
ぼくと，父親で，

	よくわからない展示会

のようなところに行った．(なんの展示会だったのか，会場はどこだったのかなどは，
まったく覚えていない)
この展示会場には，当時はやりだった LED のゲームとかがいろいろあったように
記憶しているのだが，この会場のある一角に，

	マイコン

が置いてあるコーナーがあった．(もともとは兄がそっちが目的だったらしいのだが)
このマイコンは，RETURN キーが緑色と赤色だったので，いま思えばおそらく，
東芝のパソピア７だったのだろうとおもう．
このマイコンでは，実際に BASIC のプログラムをいろいろいじる，というような
デモが行われていたらしく，

	BASIC のプログラムリストが画面上にダンプされていて，
	カーソルが左上で点滅しているだけ

だった．ちなみに，この「マイコン」を初めて見て，ぼくが最初に口にした言葉は，

	「ねえねえ，これってどんなゲームなの？」

だった．うーん，はずかしい．

しばらくして，近所のひとがパソコンを持っているというので，
兄といっしょに触らせてもらいに行くことになった．
このときあったのは，いま思えばたしか Sharp の MZ 系のマシンだったと思う．
当時はぼくはパソコンというものをまったく知らなかったので，ただ単に
兄についていって，兄がいじるのをとなりで見ていただけだったのだ．
兄がプログラムを打ち込み終って run すると，画面上に，

	2

とかの数字が出てきた．
もういちど run すると，今度は，

	6

とかの数字が出てきた．

	兄「これ，見てみ」
	僕「なに，これ？」

そう，このとき兄が書いていたプログラムは，忘れもしない，

	サイコロ

であったのである．
いま思えば，

	10 A=INT(RND(1)*6)+1
	20 PRINT A
	30 END

のようなプログラムを打ち込むのに，10数分かかっていたのだろう．

そんな兄の要望で，ついに我が家もパソコンを買うことになった．
当時兄は小学６年生で，毎週秋葉原に行っては抵抗やコンデンサを買いこんできて，
ラジオとかを作っていた(気違い小学生だ)のだが，そんなある日の日曜に，
父親，兄，僕で，いよいよ秋葉原に買いに行った．

秋葉原駅前のサトームセン(エスカレーターから外が見える建物)で選んだ
パソコンは，忘れもしない，

	PC-8001mkII

であった．たしか当時で本体価格が127,000円(だと思った)で，さらに当時はまだ
高価だったカラーディスプレイ(当時はまだ，グリーンディスプレイが主流だった)
とデータレコーダーも買ったわけだから，当時の小学生にしては，
けっこう高い買物だったとおもう．
これのおかげで今があるわけだから，親には感謝感謝である．

このときついでに，

	2001年宇宙の旅

というゲームと，あと，

	ファイヤーレスキュー

というゲームも買った．このファイヤーレスキューというのは，当時，
マイコンショップの店頭で，デモなどによく使われていた記憶があるのだが，
内容はというと，

	消防車を左右に操作して，スペースを押すとハシゴが伸びて，
	ビルの火事から人を救助する

という，非常に単純なゲームだった．しかも，画面構成は，

	キャラクタベース

だったのである．

	        ____
	       |    |
	       /\__/
	      /\/
	     /\/
	    /\/
	   /\/
	 _/\/__________
	|   |      | | \
	|   |      | |__\
	|   |      |    |
	|__/ \____/ \___|
	   \_/    \_/

というような消防車を動かすわけである．
どちらも BASIC で書いてあって，ゲーム中に Stop を押すと，

	^C
	Break in 1130

とかいって止まってしまって，なんと，

	プログラムリストを見ることができる

という，いまから考えると信じられないようなものだった．

ぼくが小４の６月に，ついに我が家にもパソコンが来た．このころは，

	パソコンが使える ＝ BASIC でプログラムが書ける

という時代だったので，ぼくもプログラムを書きはじめることになるのだが，
はじめて買ったパソコンの本は，

	BASICプログラミング

という本だった．(漫画である)
どういう内容の本かというと，

	ロムさんとラムさん

という兄弟が，

	マイコさんやアイコさん

のために，家計簿だとか，社員の定期券の期限の計算用プログラムとかの
プログラミングをしていく，という内容だった．
しかし，なんというか，今思うと，

	すごい名前だ

ちなみにアイコさんはマイコさんの妹で，アイコさんはショートカットの OL で，
ロムさんはマイコさんが好きで，ラムさんはアイコさんが好き，という設定だった．
ぼくは，長女系のマイコさんより，次女系のアイコさんのほうが好きだったなあ．

この本で気になったのは，キーボードを叩くときの効果音が，

	ピッピッ

なのである．キーボードを叩いたときに，ピッピッなんて音がするパソコンなんて
ないよなあ，と子供ながらに思ったことを記憶している．

この本は BASIC をあるていど知っていることを前提にしていて，
実際にプログラムを書いていく，という内容だったので，まったくの初心者の
ぼくには，よくわからなかった．
そこで次に買った本が，

	まんがパソコンゼミナール(きぎようへい・さとう光)

この本は，なんと，いまだに自宅に保存してある．
どういう本かというと，

	マイちゃんとコンちゃん

が，名機 PC-8001 を使って，「先生」と「ネコちゃん」といっしょに，
コンピュータの仕組みや，プログラムの書き方を勉強していく，という内容だった．
しかし，なんというか，この本の登場人物も，

	コテコテの名前

で，苦笑してしまう(だって「マイちゃん」と「コンちゃん」だよ)．
昔はこういうのが多かったもんだ．
この本はとてもわかりやすくて，

	データバスやアドレスバスやコントロールバスや ROM や RAM や
	モニタプログラムや BASIC インタプリタや入力装置や出力装置や
	入出力装置や機械語

といった，ハードのこともちゃんと解説されていて，とってもためになった．
この本は，ボロボロになるまで，100回以上繰り返し読んでいると思う．

この本の最後を飾っていたプログラムは，「センスイカンノエ」というものである．
どういうものかというと，たしか，

10 REM センスイカンノエ
20 PRINT CHR$(12)
30 LOCATE 20,10
40 PRINT "センスイカンノエ"
50 FOR I=0 TO 1000
60 NEXT
70 PRINT CHR$(12)
80 LOCATE 0,10
90 PRINT "      ■      "
100 PRINT "/~~~~~~~~~~~~\"
110 PRINT "\____________/"
120 END

というようなものだったと思う．

	FOR I=0 TO 1000
	NEXT

で，十分なウエイトになってしまうあたりが，すごいとこだ．

そーいえば，このころってまだ，

	マイコン

って言葉が使われていた時代だったなあ．

ぼくがプログラミングをはじめたころは，BASIC が全盛の時期だった．
当時は BASIC のプログラムが載っている本が多くあって，
なにをかくそうぼく自身，本に載っているプログラムを

	ゲームやりたさで

ひたすら打ち込んで，プログラムをおぼえた，というクチである．
プログラムを打ち込み終って，どきどきしながら run させると，
必ずといっていいほど，

	Syntax Error in 30 (いきなり３行目だったりする)

などと言われてしまって，それから本とディスプレイを照らしあわせるという
あまりやりたくない作業になるわけである．
Syntax Error なら，まだいい．たいていはそこの行にミスがあるからである．
やっかいなのは，

	Illegal function call (関数やステートメントに渡す値がおかしい)

とかである．これだと，たいていは，その行ではなく，別の行に間違いがある．
いちばんイヤだったのは，

	Subscript out of range (配列の範囲をこえたアクセス)

だ．これだと，まず間違いなく，別の行にミスがあって，変数の値が
おかしくなっているのである．
しかしそれも，

	(タダで)ゲームがやりたくてたまらない小学生

にとっては，それほど苦ではなかったようである．
この苦労(?)のおかげで，いま思えば，フリーソフトウエアプログラマにとって
もっとも重要な力である，

	どんな問題が起きても，自力でなんとかする気力

が身についたと思う．

どんな本を参考にしていたかというと，一番さいしょに読んで打ち込みはじめたのは，
いまでも覚えている，知る人ぞ知る，ナツメ社の，

	はるみのゲームライブラリII

という本だった．この本は残念ながら，どこかへいってしまった．
うーん，もう一度，読んでみたいものである．
「あるけあるけゲーム」(tron のようなゲーム)とか，「スクロールジャンプ」とか，
「ビルディングクラッシュ」とか，「地底探検ゲーム」とか，ペンゴもどきとか，
月面着陸とかを打ち込んでは遊んでた．
この本は当時はやりの，

	１画面プログラム

を集めた本(しかも，40x25)で，わりと手軽に打ち込めるプログラムが
多かったのだが，それでもパソコンを覚えたての小学生ではキーを探すのも
ままならず，１本を入力するのに２時間とか３時間とかかかっていた．
しかしそれでも，

	(タダで)ゲームをやりたいという熱意

は強く，学校が終ったら急いで帰って，きのうの続きを打ち込みはじめる，
という日も多かったように思う．
当然，学校でもゲームのことばかり考えているわけであるから，困ったものだ．

	はるみのゲームライブラリ

という本のプログラムも，よく打ち込んだ．
そのうち打ち込んだゲームを適当に改良したりするようになる．

やがて，自分でもゲームを作り出すようになる．
はじめて作った記念すべき１作目のゲームは，いまでも覚えているが，

	「レーザーパックマン」

というタイトルだった．
どういうゲームかというと，

・まず，敵がいる．(ランダムで動いている)
・自分がいる．(テンキーの '1', '2', '3', '5' で移動できる)
・自分と敵の X 座標が一致すると，「ピッ」と音がして，レーザーが発射される．
  (IF X=EX THEN LINE(X,Y)-(EX,EY),"■",2 のようなことをやっているわけである)
・自分と敵の Y 座標が一致したときも，おんなじ．
・レーザーを撃つと，スコアが増える．

パッと見てまず思うだろう．そう，このゲームには，

	ゲームオーバーがない

のである．
いま思えば，こんなしょーもないゲームでよく遊んでいたものだと思う．
今，思いだせる限りで，レーザーパックマンを再現してみよう．

10 X=20:Y=12:TX=10:TY=10:S=0
20 LOCATE X,Y:PRINT " "
30 LOCATE TX,TY:PRINT " "
40 I$=INKEY$
50 IF I$="1" AND X>0 THEN X=X-1
60 IF I$="3" AND X<39 THEN X=X+1
70 IF I$="5" AND Y>0 THEN Y=Y-1
80 IF I$="2" AND Y<23 THEN Y=Y+1
90 IF INT(RND(1)*2)+1=1 THEN TX=TX-1:GOTO 130
100 IF INT(RND(1)*2)+1=1 THEN TY=TY-1:GOTO 130
110 IF INT(RND(1)*2)+1=1 THEN TX=TX+1:GOTO 130
120 TY=TY+1
130 LOCATE X,Y:PRINT "○"
140 LOCATE TX,TY:PRINT "●"
150 IF X=TX AND Y=TY THEN LINE(X,Y)-(TX,TY),"■",2:S=S+100:BEEP1:BEEP0:GOTO 170
160 IF X=TX OR Y=TY THEN LINE(X,Y)-(TX,TY),"■",2:S=S+10:BEEP1:BEEP0
170 LOCATE 10,0:PRINT S
180 GOTO 20

なにしろはじめて書いたプログラムなので，相当無駄な書き方がされていたはずで
ある．そのへんも極力再現してみたが，こんなんだっただろうか．
確率的に，敵が左上のほうに行きやすくなってしまったというのをおぼえている．

	こんなんおもしろいのか？

とも思ってしまうが，自分で作ったゲームというのは，
それなりにおもしろいものである．(本当かなあ...)

ほかにも，インベーダーゲームを作ったことがある．
これは，大量のインベーダーをひとつひとつ処理することに無理があったので，

	GET(X,Y)-(X+9,Y+4),G% してから, PUT(X+VX,Y+VY)-(X+VX+9,Y+VY+4),G%

で，インベーダーをまとめて動かしていた．

このころの雑誌で忘れられないのが，

	マイコン BASIC マガジン

である．

(次回作の OMAKE.jpn に続く)

■■ 参考文献

ぼくは，本が好きだ．

本棚の専門書を分類したり，整頓したりするのが，とても好きである．

というわけで，参考文献紹介も兼ねて，ちょっと書評(ていうか，個人的な思い出話)
でも書こうかと思う．

■ C言語関係

「はじめての C 改訂第３版 [ANSI C 対応]」

ぼくが大学３年のとき，この本で C 言語に入門したので，
けっこう思い入れがある本である．
あとで知ったのだが，入門書としては，わりと名著で有名らしい．
これを参考にして，大学の授業で，

	円周率を(double 型の範囲で)計算するプログラムを作る

という課題があったときに，調子にのって，

	円周率を10万桁まで計算するプログラム

を作って提出した記憶がある．しかも，

	計算の途中経過をセーブすることができる

という，なかなか気のきいたプログラムだった．

「C プログラミング診断室」

衝動買いした本．いちおうひととおり読んだ...と思う．
たしか大学４年のとき，池袋のビックカメラにまだパソコン館が無いころ，
ビックカメラの１階の書籍コーナーで買った．
内容はちょっと古めなので，オブジェクト指向が流行りの今としては，ちょっと
古いかもしれない，と思う．

「C プログラミング専門課程」

研究室に入ってから UNIX 上で C 言語でプログラミングをするようになって，
「C 言語をもっと勉強したい!」と思って買った本．
これはためになった．この本のおかげで，コンパイラの動作とか，メモリとかが
わかってきた．

こんな疑問を持ったことを覚えている．
「char * s = "ABC"; などの文字列リテラルは，メモリ上に静的に確保される．
  ということは，
    while (1) {
      printf("ABC\n");
    }
  を実行すると，printf(); が実行されるたびに "ABC" がメモリ上に
  配置されるわけだから，そのうちメモリがなくなってしまうのではないだろうか？
」

しかも，これに対する自分の解答が，
「
    char * a = "ABC";
    char * b = "ABC";
  のように，文字列がダブっている場合には，コンパイラが判断して，
  同じ領域に割り付けたりするらしい．
  たぶん，while () で printf() を繰り返したときにも，
  これと同様に，printf() の実行時には，文字列は同じ領域に
  割り付けられるのだろう．
」

うーん，すばらしくとんちんかんというか，さすが BASIC 出身者，というか，
こうして書くこともはずかしいような疑問である．
(インタプリタとコンパイラの動作を誤解しているわけだ)

「プログラミング言語 C」(いわゆる "K&R" である)

有名な本なので，研究室に入ってからとりあえず買ってみた．ざっと読んだだけ．
「fgetc() の戻り値が，なぜ int 型なのか?」という疑問を持ったときに，
この本に解説してあったので，

	「なんていい本なんだ!」

と思って買ったんだけど，あんまりちゃんと読んでない．

「C プログラミング FAQ」

これは，いい．最高にためになる．
とりあえず１度通して読んだが，またそのうちもう一度通して読みたいと思っている．
中級者くらいになって，たいてい疑問に思うようなことは，必ず書いてあるのが
すごい．
この本に書いてあることが全般的に理解できてれば，C 言語はほぼ完璧なのでは，
と思う．

■ X 関係

「X-Window Ver.11 プログラミング[第２版]」

X のプログラムをはじめたころに，これの第１版が研究室にあったので，
よく参考にしてた．
そのうち，家で使う分と学校で使う分の２冊が欲しくなってきて，けっきょく，
第２版を自分で買った．
X のプログラミングをする人って，この本を参考にしている人がけっこう多い
みたいだね．フリーソフトのドキュメントを読んでると，参考文献とかで
よく見かけたりする．

「X-Window OSF/Motif プログラミング」

X のプログラムをはじめたころに，これを参考にしてプログラミングしてた．
はじめのうちは，Motif (正確には，Lesstif) を使っていたのだが，
やはり Motif は商品である，というのと，

	「BSD を 256 倍使うための本」(いわゆる，「黒いニゴロの本」である)

の，EmiClock 開発秘話で，

	X のプログラミングは，X ツールキットを使うのがオシャレ

というふうに書いてあった，というのがあって，だんだん Motif は使わなくなった．
でも X ツールキット専門の本ってなぜかすっごく少なくて，たいていは
X ツールキットのプログラミングをするときでも，Motif の本を参考にしたりしてる．

ちなみに，EyeClock は，

	「BSD を 256 倍使うための本」

に，すっごく影響を受けている．

■ プログラミング

「GNU ソフトウエアプログラミング」

プログラミングに emacs, gcc, make, gdb を使うときの一連の流れが
わかるので，とってもいい本だと思う．
個々のアプリケーションをひとつひとつ詳しく解説してある本はたくさん
あるのだが，開発の一連の流れとして解説してある本は，なかなか少ない．

■ システム管理

「スーパーユーザの日々」
「UNIX ネットワークの日々」
「Mail & News の日々」

研究室のシステム管理者をやるようになって，この本でいろいろ勉強した．
帰宅中の有楽町線のなかでよく読んだ．

内容はちょっと古めだが，基礎的なことがしっかりと書かれているので，
基礎勉強にとてもいい本だと思う．書いてある内容も，とてもしっかりしている．
「UNIX のシステムの勉強がしたいんだけど，なにかいい本はないか？」
「ネットワークの勉強がしたいんだけど，なにかいい本はないか？」
とか聞かれたときには，この本を推薦するようにしている．

「UNIX ネットワークの日々」「Mail & News の日々」は，研究室内の
システム管理者育成の勉強会で教材にしていた．この勉強会では，毎回，

	「K君」や「中村さん」の役を決めて，読む

しかも当然，

	セリフ付

ということをしていた．

	「え，こうすればいいんじゃないんですか？ 中村さん」
	「それは違うよ，K君．これはこれこれこうだから，こうするんだよ」
	「なーんだ，同じUNIXでも，HPとSUNではずいぶん違うんですね」

というようなセリフを言い合うわけである．(実話)
て，朝，研究室に入ってくる卒研生とかが，

	スーパーユーザーが，学芸会のセリフの練習でもしているかのような姿

をまのあたりにして，ギョッとしていた．(これも実話)

「セキュリティの日々」とかも，出してほしいもんだ．

「よしだともこのルート訪問記」

最近買ったのだが，なんていうか，ここまで，

	システム管理者の実際

が書かれているという本は，他にないのでは？ とおもう．
(そりゃそうだ，現役の管理者へのインタビューなのだから)
ほかの大学や研究室とかではどういうふうに管理されているか，というのが，
非常に幅広く紹介されていて，とてもためになる．
というのは，コンピュータやネットワークのシステムの構成など
(こういったことも非常にためになるが)が書いてあるだけでなく，

	「管理者の人材確保」や「管理者の育成・教育態勢」

がどのようになっているかなどが書かれているからだ．
やはり，「人材の確保」と「教育」がいちばん大変で重要なことであって，
こういったことが，システム管理の実態だと思う．

しかし，読んでいると，他の大学や研究室などの管理態勢や教育態勢が，

	うらやましくなってしまう

ということもある．

(次回作の OMAKE.jpn に続く)

■■ うまいもの

寿司がすきである．

おごってもらうとしたら，

1.寿司
2.焼肉
3.なんかめずらしいたべもの

の順に嬉しい．なにしろ小学生のころは，

	寿司屋になりたかった

というくらいである．
とはいっても，寿司などそうそういっつも食べにいけるものではないから，
ふだんは回転寿司にいったり，たまに寿司屋で食べるくらいである．

とはいっても，魚の名前をよく知らない．寿司屋でネタを見ても，
なんの魚だかわからなかったりする．
そのうち，ちゃんとネタの名前をおぼえて，

	「なんにいたしますか？」
	「そうだなあ．白身のいいとこを握ってくれ」
	「へい，おまち」
	「お，これはヒラメだね」

なーんて言ってみたいのだが．

ちなみに，好きなネタベスト10は，

1. 中トロ
2. ビントロ
3. サーモン，ハマチ，マグロ赤身
6. 鯛，メカジキ，サンマ
9. カニ味噌，ウニ

てなかんじだろうか．適当に考えただけなのだが．
うーん，こうしてみると，まだまだ子供の味覚である．

池袋は，やたらと回転寿司が多いので，嬉しい．

(次回作の OMAKE.jpn に続く)

■■ 携帯端末

わずか 800g 程度の Libretto SS1000 に FreeBSD と X を入れて，
電車の中だろうが，待ち合わせの「いけふくろう」の前だろうが，
ところかまわずプログラミングをしている．

・携帯端末(いわゆる，WindowsCEマシン)
・携帯Java端末
・携帯電話

ちょっと前までは，携帯端末が今後の主流になると思っていた．
しかし今では，これからは，携帯端末でなく，携帯電話が主流になって，
携帯電話でなんでもできる，というような方向に進んで行くのだろうとおもう．
というのは，携帯電話はやはり「電話」という，実用的で馴染みやすい機能が
メインであるからだ．
「GPS標準搭載の携帯端末」があったとしても，GPSをやるためにわざわざ
携帯端末を買って，操作をおぼえようとする人は少ないだろう．
しかし，「GPSつき携帯電話」ならば，携帯電話が欲しい人で，物珍しさで
買ってしまいそうな人が出てくるような気はする．

きっとそのうち，携帯電話に Java や Linux が搭載され，美術館に行ったら
自分の携帯電話に案内が自動的にインストールされて，自分の携帯電話が
案内してくれる，というようになるのだろう．

携帯電話のメモリサイズや処理能力はどんどん進化しているから，いまパソコンで
できるようなことは，ぜんぶ携帯電話でできるようになってしまう．
そのうち映画とかも見れるようになって，電車の中の10分くらいの中途半端な
自由時間に，ちょっと映画をみたり，ロールプレイングゲームの続きをしたり，
電子ペットにえさをあげたりするようになるのだろう．

携帯電話のいいところは，小さくて電車の中とかでいじっていても違和感は無いが，
多彩の機能を盛り込める程度には大きい，というところだ．
たとえば，GPSつきのごつくてでかい腕時計が出ても，それをいつもつけようとする
人はいないだろう．
また，「違和感が無い」というのはとても重要だ．
ぼくのようにところかまわず人目も気にせず，いつどんなところでもプログラムを
書き出してしまうような人間はともかく，普通の人は，やはり人目は気になる
(のだと思う)からだ．

(次回作の OMAKE.jpn に続く)

■■ 電車で書くプログラム

ぼくは通勤に片道１時間半かかるのだが，この時間は貴重なプログラミングの
時間になっている．もともと就職するときに，ずいぶん遠くにある会社だけど，
まあ，混まない方向だし，ずっとプログラム書いてればいいか，とおもって就職を
決め，就職前の２月に Libretto SS1000 を購入し，ほんとに車内で書くようになった．

東急田園都市線の反対方向に乗っているので，行きも帰りも必ず座れる．天気の
いい日は通勤中にもかかわらず，

	玉川でついつい降りたくなってしまう

一応，降りたことはないけどね．

帰りは渋谷乗り換えなのだが，調子に乗って書いてると，ノリにノッてきて

	渋谷をそのまま乗り過ごした

ということが何度かある．また，あまりにノッていると，渋谷で乗り換えた後も，
続きを書きたいという欲求を抑えることができずに，

	山手線の中で，立ってプログラムを書いた

ということも何度かある．XFireworks の一部分のコードは，山手線で立って書かれた．

EyeClock や N.A.D.A.R. や XFireworks や WonX のコードの大部分は，こうやって
電車の中で書かれた．今思えば，

	ずいぶん書いたものだ

田園都市線の車両は，何種類かある．その中でも旧式なのだろうか，車両の端の席に，
肘をかけられるくらいの出っぱりがある車両がある．これは，いい．出っぱりの
上に Libretto と飲物を置いて，優雅に書くことができる．出っぱりがない車両だと，
膝の上に Libretto を乗せて書くことになる．

(次回作の OMAKE.jpn に続く)

■■ モバイルについて

ノートパソコンやモバイルについて思うことなんだけど，もしもモバイルと
いうならば，やはり，

	本当に持ち歩けること

というのが，絶対条件だと思う．のだが，

	本当に持ち歩けるの？

と疑問になってしまうような製品が多々あると思う．
たとえば，いくら軽くて小さくて高性能だとしても，22万円もするようなノートPCを
そのまま，

	無造作にバッグにぽんと入れて

気軽に持ち歩くことができるだろうか．(ぼくはできない)
だから，高価な製品は，それだけで(モバイルとしては)ダメだと思う．
もっと安っちくて，落としても無くしても置き忘れても，(それほど)ショックが
少なくて，古くてぼろくて傷だらけで，

	だれも盗もうなどと思わないくらいのマシン

が，モバイルとしては最適だと思う．

重量は，可能な限り軽いほうがいい．1kgを超えると常に持ち運ぶのが苦痛になる．
また，電源アダプタも小さいほうがよい．実際に持ち歩くと，大きさよりも
重さのほうが気になるので，小さいことよりも軽いことのほうが重要た．

インターフェースは，PCカードスロットが１つあれば十分である．データのやりとりを
するのは，LANカードかコンパクトフラッシュが現実的である．USBはあるにこした
ことはないが，それによって高価になったり重くなったりするくらいなら，
無くてよい．そもそもUSBがあったとしても，どうせつなぐのは

	キーボードかマウス

くらいのものである．そもそもモバイルでマウスを使いたいなんて欲張っても
しょうがない．
もしかしたら，

	フロッピードライブか CD-ROM ドライブ

をつなぎたいかもしれない．
しかし，モバイルの場合には，このような，

	ふだん絶対に持ち歩かないもの

のことを考えてはいけない．機能を限定して，軽く，持ち運びやすく，
いつでもどこでもがモバイルのウリなのだから，あれも使いたいこれも使いたいと
言い出したら，なんのためにモバイルを使うのか，本末転倒になってしまう．
だから，

	PCカードスロットだけで十分

なのである．

モバイルでいちばん気になるのは，結局のところ，

	１に値段，２に重量，３にバッテリのもつ時間

である．値段というのは買うときに高い安いということではなく，
前述したように，高価なものは気軽に持ち歩けないという意味である．

OS に関しては，(ひいき目なしで)FreeBSD か Linux が最適だと思う．

たとえば Windows だと，出先でちょっと PC カードタイプの LAN カードを
借りて使いたいというときに，ドライバが入っていないとどうしようもない
ということにおちいりがちである．たぶんインターネットに接続できるパソコンを
借りて，ドライバをダウンロードして，コンパクトフラッシュ経由でモバイル側に
もってってインストール，という，まあ，あまり考えたくないような，

	とても面倒なこと

になる．
インターネットにつながってるPCやコンパクトフラッシュやコンパクトフラッシュが
使えるノートパソコンがなかったときのことなど，もう，

	想像もしたくない

出先で借りものの LAN カードを使うこともできないなんて，これでモバイルと
言えるのか？ ぜんぜん実用的じゃないじゃん，と思う．

FreeBSD や Linux なら，はじめから GENERIC なカーネルを作っておけば，
たいていのPCカードは指しただけでそのまま使える．指しただけで使えなかったと
しても，カーネルをコンパイルしなおせば，ほとんどのカードがまず使える．

モバイルでは，出先にもっていって使うことが多いので，出先でPCカードを
ちょっと借りる，ということはとても多い．逆にいえば，もしも出先で借りることが
できるなら，余分な PC カードを常に持ち歩かなくてもよい，ということになる．

また，FreeBSD や Linux では，X のデスクトップ環境をカスタマイズすることで，
マウスをほとんど使わないようにカスタマイズすることができる．
Libretto では，液晶ディスプレイのとなりについてるぐりぐりしたやつで
マウスを操作することになる．しかしぼくの場合，Window Manager をカスタマイズ
することによって，ほとんどマウスを使わずに作業できている．
Windows で使用することなど，想像もしたくないものである．

さらに，OS やアプリケーションの軽さの問題がある．前述したように，
モバイルはできる限り安っちくてロースペックなマシンのほうがよい．
だから，マシンは，Pentium MMX 166MHz の RAM 32MB とかでもいいし，
もっとロースペックでもいい．しかし，たとえこれでも，アプリケーションは
あまり問題なく動いてくれないと困る．(モバイルなので，サクサクと動けとは
言わないけど，不安定で落ちまくったりするのは困る)
あるアプリケーションを動かすためだけに，高価なメモリを32MBも追加増設する
なんて，非常に無駄なことである．こんなことをしていたら，けっきょくどんどん
高価になっていってしまう．とにかく高価なものは持ち歩きたくないというのが
ぼくの信条だ．値段が高いものを買うのが嫌というよりも，持ち歩くのが嫌なのだ．

あとは，インストールのしやすさの問題だ．モバイルだとCD-ROMドライブが無い
(あっても別売り)とか，フロッピードライブが無いということが多いので，
インストールが困難な場合が多い．FreeBSD や Linux ならば，ネットワーク
インストールや Windows 側にファイルを置いておいてインストールなど，
多彩な方法をとることができる．

最後に意外に重要なのが安定性の問題だ．というのは，プレゼンに使用することが
あるからだ．(プレゼンをやらないならばあまり関係ないけど)
いざプレゼンをやろうとしたら真っ青な画面になってしまい，結局資料無しで
プレゼンを進める，というのを何度か見たことがある．
なんというか，悲しいというか，せっかく昨日徹夜して資料作ったのだろうに，
と思う．
(プレゼンに資料をまったく作って来なかったのと同じだと個人的には思っている)
こんなことで10分間のプレゼン中に，再起動に(ロースペックだし，ファイルシステムの
チェックもするので)３分間もかかっていてはかなわない．
UNIX には満足のいくプレゼンツールが無いと言われるかもしれないが，
きれいな画面でちょこまかした(たいていあまり意味の無い)アニメーションを
見せたり，プレゼン画面にきれいな背景があったりすることのほうが，
いざプレゼンというときに，OSがまったく動かないことがあるということよりも
重要なのだろうか，と思う．説明したいことをテキストファイルに書いておいて，
less でテキストファイル見せながらしゃべればいいんじゃないの？ と思う．
X を起動する必要すらあまり無いと思う．
図を見せたいならばXの仮想画面を何枚か用意しておいて，別の仮想画面に
適当な画像ビューワで画像を開いておいて，仮想画面を切替えるのがいちばん確実だ．
字が小さければ，でかいフォントを使えばいい．
ブラウザの不安定さがちょっと心配だが，HTML で書いておいてブラウザで見る，
という方法もある．これだと資料をそのままホームページに張り付けることも
できるし，画像も使えるし，フォントのサイズも自由に選べる．

ぼくの経験だと，いっしょうけんめい文字をスライドさせたりフェードインさせたり
箇条書の項目が順番に出てきたり，意味もなく凝ったアニメーションとかやっている
プレゼンほど，あまり内容が無かったりするものだ．(これは，ほんとうにそうだと
思うね)
シミュレーションの結果の発表とかで，ほんとに動くものを見せようとして，
アニメーションをやっているのならいい(そういうアニメーションは，むしろ歓迎)
のだけれど．まったく意味の無いアニメーションってホント，多い．(しかもそれを
見てプレゼンがうまいとかきれいとか，(たとえ社交辞令にしても)褒める人が
いるのだから困ったものだ．内容はどうだったんじゃいと突っ込みたくなる)
ほんとにプレゼンのうまい人や経験のある人は，でかい字でキーワードだけ
箇条書にして映し出させて，あとはそのキーワードを見て思い出しながら
しゃべったりする．プレゼンって，自分が今までやってきた，自分が一番よくわかって
いることを発表するのであるから，これがあたりまえであるとも思う．
(長々とした文章が小さい字で画面いっぱいに映し出されたと思ったら，発表者は
 その文章を読むだけ，というプレゼンがたまにあるけど，なんというか，経験を
 つんでくれ，と思う)
だから，プレゼンなんて，less と xv が使えれば十分である．なんかプレゼンの
話，というか，愚痴になってしまったなあ．
でもせっかく書いたのを消すのももったいないし，まあいいか．

(次回作の OMAKE.jpn に続く)

■■ ゼビウスについて

いきなりだが，ゲームの話である．

むかしむかし大昔，ゲームセンターのゲーム(いわゆるアーケードゲーム)の黎明期に，

	XEVIOUS

というゲームがあった．「ゼビウス」と読む．
縦スクロールタイプのシューティングゲーム，というと説明は簡単なのだが，
その斬新な構図と演出で，一世を風靡したゲームである．レバーで自機を操作して，
空中攻撃弾(ザッパー)と地上攻撃弾(ブラスター)で敵を攻撃しつつ，エリアをクリア
していく，というゲームである．エリアは16エリアまであって，16エリアをクリア
すると，7エリアに戻る．全機がやられない限りは，延々とループするわけだ．つまり，

	ゲームクリアというものが無い

というゲームである．

XEVIOUS には，カウンターストップというひとつのステータスがある．
カウンターストップ，通称「カンスト」とは，

	9999990点

のことである．ここまでいくと，これ以上点数が上がらなくなるのだ．これが
「カンスト」である．これができるプレイヤーのことを，「カンストプレイヤー」
とか，「1000万点プレイヤー」とか言ったりする．
と，口で言うのは簡単だが，カウンターストッププレイヤーがどれくらいの
ものかというと，

	ゲームをしている後ろに人だかりができてしまう

というくらいのものすごい実力なのである．(ちょっと言いすぎ)

XEVIOUS は標準の設定だと，60000点で１機増える．カウンターストップさせるくらいの
実力になると，画面最下に，

	自機の残りがずら〜〜〜っと並んでいる

ということになる．そういえば，むかしそんな状態になっていたときに，
後ろを通り過ぎていった人が，「すげえうまいよこの人」と言ったあと，

	「あんなにボムが残ってる」

と言ってたことがある．ボムではなくて自機なんだけどなあ．

1000万点までいくのにどれくらい時間がかかるかというと，
ぼくがはじめてカウンターストップさせたときは，午後の１時半から始めて，

	７時間半かかった

夜の９時までやっていたわけである．目安としてははじめのうちは１時間で
100万点なのだが，だんだんステージを過ぎていくと，点数が上がってくる
ようなので，少しずつ効率がよくなってくるのである．
XEVIOUS は昔のゲームなので，当然，continue などは無いわけである．だから，

	100円玉一枚で

これだけ粘らなければならない．
このあいだ，食事もとらず，トイレにもいかず，である．昼間のゲームセンターは
学生が多いのだが，だんだん社会人が増えてきて，

	客層が移り変わっていくのがわかってしまう

１時間くらいの時間がちょっとできたとき，暇つぶしにプレイすることがたまにある．
こんなときはカウンターストップさせるほどの時間は無いわけであるから，
適当な時間でわざとやられて GAME OVER にするわけであるが，このようなときは
そのまま GAME OVER にしてはいけない．そこで力尽きたと思われてしまうからである．
必ず，

	100万点

とか，

	99万9990点

にそろえなければならない．これもカウンターストッププレイヤーのひとつの
プライドである．このように点数をそろえることによって，ネームエントリーに，

	おれはほんとはもっと先までいけたんだけど，わざとここでやめたんだぞ

というメッセージを残しておくわけだ．
このためには，トーロイドは30点，ゾルバグは100点，テラジは600点，
ギドスパリオは10点，ザガートは150点，流れザガートは100点，などというように，
敵機や地上物の点数まで正確に把握しておいて，

	点数を調整しながらプレイする

というくらいの実力が必要である．
だから，XEVIOUS のハイスコアランキングを見たときに，

	1234560点

とかになっていたとしたら，ああ，さっきまですごいプレイヤーがプレイして
いたんだな，と理解しなければいけないのである．

慣れてくると，1000万点いくのにかかる時間もだんだん短縮されてくる．
機数に余裕があれば，

	得点の高いエリアでわざとなんどもやられる

(９エリアとかだ)とか，ジェミニ誘導という高等技術を使って，短時間で得点を
かせぐことができるようになるからだ．エリアの途中でやられると，エリアの先頭に
戻るので，同じエリアをなんども繰り返せるのだ．

しかし，それでも最低４時間くらいはかかる．そこで，XEVIOUS をやるとき，
100円玉を入れる前には，

	それなりの心構えが必要になる

ここでその心構えについて書こう．

まず，重要なのは椅子だ．ゲームセンターの椅子は座りごごちがあまりよくない
ものが多いが，２種類の椅子があるゲームセンターは多い．できるだけ座りごごちの
良い椅子を持ってきて使う．背もたれつきのものがあれば，なるべくそれを使う．
ここで，

	椅子を持ってくるのなんて恥ずかしい

とか，

	椅子なんてなんでもいいや

などと思ってはいけない．これからその椅子に何時間も座るわけであるから，
椅子は重要な要素なのだ．

飲物は，必ず用意したほうがよい．プレイ前にどんなに喉が渇いていなくても，

	３時間もやっていれば必ずなにか飲みたくなってくる

しかし，飲物は大量に飲んではいけない．トイレが近くなるからだ．

	ちょっと唇を濡らす程度に

ちびりちびりと飲むようにする．
プレイ中には甘いものが欲しくなってくるので，オレンジジュースなど，なるべく
あまったるい飲物を選んだほうがよい．コーラなどの炭酸飲料は

	気が抜けてしまうことも考えなければならない

のである．

食糧も準備したほうがよい．プレイ中は甘いものが欲しくなってくるので，
ひと粒チョコやキャンディーのように，簡単に口に入れられるものをポケットに
大量に用意しておくようにする．ゲームセンターに灰皿があれば，持ってきておく．
これは，チョコレートの包み紙をまとめておくためだ．

問題は，トイレだ．
プレイ前には，どんなにトイレに行く必要は無く感じても，必ず行くようにする．
これは行かないと，ほんとうに絶対に後悔する．

しかし，上級プレイヤーになってくると，

	プレイ中にトイレに行くことができる

ようになる(実話)．機数が半減してしまうのを承知の上で，ゲーム中にトイレに行って
しまうわけだ．
７エリアは，はじめにバキュラの応酬があるので，ほっておいてもやられにくい．
後ろに人だかりができているとき，プレイの合間に，悠々と

	缶ジュースなどをちょっと買ってこれる

ようになれば，上級プレイヤーといえるだろう．(これも実話)

だれも信じてくれないのだが，両腕を交差させてプレイしたことがある．
XEVIOUS はあまり点数をとりすぎると，それ以上プレイできなくするように，
レバーやボタンが突然入れ替わったりすることがある．(そういう設定ができるらしい)
以前，あるゲームセンターでやっていたところ，400万点ほどのところで，

	いきなり操作不能になった

これは噂のボタン入れ替わりかとおもっていろいろいじってみると，

	レバーが１プレイヤーと２プレイヤーで入れ替わり，
	空中弾(ザッパー)が撃てなくなっていた

昔のテーブルタイプの匡体だったら，プレイを続行するのは難しかっただろう．
たとえ反対側に行って２プレイヤー用のレバーで操作したとしても，
画面は１プレイヤーのほうを向いているわけだから，動きが逆向きになるからである．
ところが，この時代の匡体は，ストリートファイター２が既にあった時代で，
２人が並んで対戦プレイできるタイプの匡体であった．
匡体の操作パネルは，こんなかんじだ．

	1Pレバー               1P START   2Pレバー
	  ●    1P地上攻撃ボタン  ○        ●    2P地上攻撃ボタン
	    ＼        ○          ○          ＼        ○
	          ○           2P START             ○
	    1P空中攻撃ボタン                  2P空中攻撃ボタン

つまり，２プレイヤー用のレバーはすぐとなりにあるわけだ．しかし，地上攻撃
(ブラスター)の発射ボタンは１プレイヤーのままで変わっていない．
そこで，

	左右の腕を交差させて，左手で2Pレバーを操作して，右手で1P用の
	地上攻撃ボタンを押す

ということになった．しかも，ザッパーが発射できないので，

	空中の敵は，撃てない

という苛酷な状況である．
しかし，こんな状況でも，なんとか１時間くらい粘って，最終的には600万点くらい
までいった．しかしこれを後輩に話したら，

	話作んないでくださいよ

とつっこまれてしまった．実話なんだけどなあ．

うーん，マニアックなネタになってしまった．

(次回作の OMAKE.jpn に続く)

■■ テトリスについて

テトリスにもカウンターストップがある．レベル99，ライン999，スコア999990点，
というのが，それである．ぼくは，１度だけ，テトリスをカウンターストップ
させたことがある．もちろん，

	100円玉１枚

でだ．
テトリスのカウンターストップは，だいたい１時間半くらいでできる．しかし，
XEVIOUSに比べて，はるかに難しいと思う．というのは，テトリスというのは
いちばん上まで積まれたらそれで終わりなわけであるから，プレイ中にちょっとでも
気を抜こうものなら，

	その瞬間にゲームオーバーになってしまう

つまり，１時間半という時間の間，集中力を切らさずに持続させる必要があるのだ．
XEVIOUS では，７エリアのバキュラの応酬や，９エリアのシオナイト，
11エリアの先頭付近など，気を抜ける場所が何箇所かある．ちょっと息抜きに
なにか食べようかとも思うものである．しかし，テトリスでは，

	プレイ中にキャンディーの包みをほどく，なんて暇はない

まあそこまでいうと大げさで，実際にはチョコレートの包みをほどいたり，
飲物をちょっと飲むくらいできるが，基本的には腹が空こうが喉が渇こうが，

	１時間半我慢する

というプレイを要求されるわけである．

テトリスも，上級レベルになるといろいろな技を使えるようになってくる．
階段状になっている一番高いところにブロックをいったん置いて，徐々に落として
時間を稼ぐ「階段落とし」とか，一見スキマができてしまうような置きかたに
見えるのだが，実はラインがうまく消えてくれて，スキマは無くなる「入れ消し」，
などというのがよく使われるテクニックである．しかし，これぞ上級者のテクニックと
いうならば，それはやはり「回転入れ」だ．

	      □□□
	        □
	
	■■■■    ■■■■
	■■■■    ■■■■
	■■■      ■■■■
	■  ■■■■■■■■

とか，

	        □□
	      □□
	
	■■■    ■■■■■
	■■■      ■■■■
	■■■    ■■■■■
	■■■■■■■  ■■

とか，

	        □
	        □
	        □□
	
	■■■■    ■■■■
	■■■■      ■■■
	■■■■      ■■■
	■■  ■■■■■■■

とかを入れてしまうテクニックだ．
レベル99でブロックがガンガン落ちてきている状態で，

	      □□□□
	
	■■■■    ■■■■
	■■■        ■■■
	■■■■    ■■■■
	■■■■■  ■■■■
	■  ■■■■■■■■

のようなのを「回転入れ」と「入れ消し」でうまく入れたりすると，

	ギャラリーが寄ってくる

かもしれない．

うーん，これもマニアックなネタになってしまった．

(次回作の OMAKE.jpn に続く)

■■ ソースコードを公開することについて

Windows のフリーソフトとかで思うことなのだが，ソースが添付されてないものが
多い．というか，添付されてないのが普通である．これがぼくには不思議で
たまらない．なぜソースコードを添付しないのだろうか，と，ついつい理由を聞きたく
なってしまう．
もしもそれが，「どうせソースコードを添付したって，だれも見ないだろう」とか，
「普通の人はコンパイラなんてもってないから，ソースを添付する意味は無い」
などという理由なのだとしたら，それは大きな間違いだ．

まず，ソースが添付されていた場合に，それを見るか見ないかという話であるが，
実際のところ，見る人は少ないだろう．しかし，見る人は見る．見る人は必ずいる．

(次回作の OMAKE.jpn に続く)

■■ FreeBSD について

ぼくのいままでのコンピュータ歴の中で一番大きかったことは，FreeBSD との出会い
だったと思う．FreeBSD のなにが素晴らしいかと言うと，一言で言うならばそれは，

	開発環境がある

ということだ．これは

	作ることができるOS

ということである．いろいろな意味で，である．

Cコンパイラは標準で(正確には GNU の成果物である)ついてくる．emacs や make，
gdb などの素晴らしい開発環境もついてくる．動作するアプリケーションは，
たいていソースコードフリー(自由，という意味のフリーである)のものである．
これはぼくのような，

	まさに作ることがだいすきな人間

には，たまらない素材だ．「作る」ための材料や道具，資料がそこらじゅうに
いっぱいなのである．
いちばんうれしいのは，作るためのネタというか，「きっかけ」に満ちあふれて
いることだ．だから，目の前に FreeBSD マシンが１台あるだけで，まったく飽きない．
ネタはいくらでもあるので，１日中ずっと調べ，試して，作ることができる．
(ちょっといいすぎか？)

とはいっても，はじめからそこまでわかってて使いはじめたわけではない．
使っているうちに，そういったことがだんだんとわかるようになり，それが自分に
マッチしていたためにさらに深く使うという好循環(悪循環？)で，どんどん深みに
はまっていったわけである．自分がモノ作りが好きだということをわからせてくれた
OS でもある．(それまでもいろいろと作っていたが，無意識で作っていたと思う)

FreeBSD が無かったら，今こんなにコードを書いてはいないだろう．カーネルや
デバイスドライバに興味を持つことも無かったかもしれない．しかし，FreeBSD なら
いくらでも自分で作ることができるわけだから，モノ作り大好き人間にとって，
こんなに興味をそそり，刺激を受ける素材はない．

実際のところ，FreeBSD はいい OS であり，いい開発環境である．そして僕自身にも
合っている．今後もずっと使い続けていくだろう．

しかし最近，ぼくの中ではその対抗馬が出てきている．それは NetBSD だ．

FreeBSD と比べて NetBSD は何が違うのかというと，ぼくにとっては，

	おもしろいOSである

ということである．それは NetBSD のソースの sys/arch の下で ls をするとわかる．
NetBSD が移植されたマシンのディレクトリが延々と出てくるのだ．

NetBSD が面白いと思いはじめたきっかけは，カーネルを見たりいじったりするように
なってからだ．パームコンピュータやモバイルなどを見たとき，FreeBSD は
(移植すれば別であるが，今のところはまだ)動かないだろうと思う．しかし，
NetBSD は動くことが多い．たとえ動かなくても，誰かが移植するかもしれない．
たとえ誰も移植しなくとも，自分ももっと勉強して力をつければ，将来は自分で移植
できるかもしれないという夢がある．携帯電話やカーナビだってそうだ．
だから，ぼくにとって NetBSD は「夢のあるOS」だ．

そういう意味で，Linux も夢がある．ぼくが Linux をあまり使わない(カーネルの
ソースを読むことはあるが)のは，単にはじめに FreeBSD から入って，その流れで
NetBSD を読んでいるからだが，あまり使ってないのはちょっと残念な気もする．

NetBSD にも弱点はある．NetBSD の場合だと，使う人 ＝ 作る人 という意味あいが
強いので，ユーザ環境は FreeBSD や Linux ほどには整備されていないように感じる．
そんなわけで，使うには FreeBSD，作るには NetBSD が自分にとっては最適だと
思っている．

ぼくがはじめて FreeBSD と出会ったのは，大学４年で研究室に配属されたときだ．
当時研究室には HP-UX のマシンが数台と，FreeBSD の入った AT 互換機が数台，
MS-DOS の入った PC-9801 が数台あった．以前は HP-UX のマシンをメインとして，
PC-9801 から telnet して計算を走らせるみたいな使いかたをしていたようだ．
ぼくがいた部屋には FreeBSD マシンは２台しかなく，HP-UX よりも高速で軽かった
ため人気があり，ぼく自身あまり使うことはなかった．そもそも大学４年のときは，
C言語の勉強に注力していたため，UNIX というものをあまりしらなかった．login
しても，

	自分のホームディレクトリ以外の部分は見たことが無かった

というくらいである．自宅に PC-9801 があり，当時はそちらをメインで使っていた
ために，UNIX も C 言語を書くためのプラットホームとしてしか使っていなかった
のだ．

そんなわけで UNIX についてほとんど知らないまま修士１年となった４月のこと，
当時の研究室のシステム管理者だった N さんに言われた．

	坂井君，スーパーユーザーをやってくれない？

UNIX をまったく使えない人間としては「スーパーユーザー」なんていう，

	いかにも特権階級のような

言葉の響きは魅力的であり，なにも考えずに引き受けた．そして初めての仕事が，

	とりあえずこのマシン好きにしていいから，
	FreeBSD を入れてみてくれない？

である．UNIX のことは login の仕方しか知らず，AT 互換機のことはほとんど知らず，
ネットワークのことは ftp と telnet と rlogin の使いかたしか知らない，という
状態のぼくに，http://www.jp.freebsd.org のアドレスだけ教えて，

	インストールからネットワークの設定まで

いきなりすべてやらせようというのであるから，今思うと，

	なんて無茶な方法だ

と思ってしまう．

こうして初めての FreeBSD との取っ組み合いが始まったわけである．

2002/1
(次回作の OMAKE.jpn に続く)

■■ カーネルについて

カーネルのソースを読むことは楽しい．最近は PowerPC のアセンブラが(少しだけ)
わかるようになってきたので，さらに楽しくなった．

カーネルの勉強をしてみたいんだけど，

	なにから手をつければ良いかわからない

という人は多いと思う．実際，ぼく自身もそういう時期があった．ここで，ぼくなりの
カーネルの読みかたを，無謀にも書いてみようと思う．とはいってもぼく自身，
それほどよく読んでいるというわけでもないし，まだまだ入門者の域を出ていない．
しかもぼくの場合，読むのはブートローダー，ブートストラップ(それも一番はじめの
ほう)とデバイスドライバが主(ていうかそれ以外はあまり読んだことが無い)で
あるので，偏った話になると思う．参考までに読んでもらえればと思う．

カーネルにしてもブートローダーにしても，まず，どこからはじまるのかを
知りたい人は多いだろう．カーネルやブートローダーの場合には，main() 関数から
始まるというわけではない．だから，

	grep main *

とかしても無駄である．多くのばあい，アセンブラのコードのどこかに
startup: のようなラベルがあり，そこから始まるようになっているのである．
これは NetBSD だと sys/arch/[アーキ名]/[アーキ名]/locore.s にあるのだが，
これを探すにはどうするか．それは，Makefile を読むのだ．

Makefile を読むと，リンカを使ってカーネルモジュールの最終リンクを行ない，
最終的なカーネルオブジェクトを作成する部分が必ずあるはずだ．このとき，
ELF などのオブジェクト形式で作成するためには，スタート地点の指定が必要なので，
スタート地点を指定している部分が必ず存在する．リンカは多くの場合 GNU の ld を
使用しているであろうから，Makefile 中で，ld を使用している部分を探す．
これはふつうのまっとうな Makefile なら，LD ?= ld というように変数に置き換えて，
$(LD) のようにして使用しているはずである．そのような場所を探す．
(ひょっとしたら gcc からリンカを呼び出すことで，ld を直接使ってない場合が
 あるかもしれないので注意である)

で，ld を使用している部分を見つけたら，以下のオプションに注意する．

	-e [entry]		スタート位置のラベルの指定
	-Ttext [address]	テキストセグメントのアドレスを指定
	-c [commandfile]	LD script ファイルを指定
	-T [commandfile]	-c と同じ

-e でスタート位置を指定していたら，そのラベルの位置がテキストセグメントの
先頭にくるということなので，まさにそのラベルの位置から実行が始まる．
あとは grep でラベルを探すだけである．
-c や -T で LD script ファイルを指定している場合には，その LD script ファイルの
中で，セグメントの分割方法を細かに指定しているはずである．その中で
テキストセグメントの先頭に配置されているラベル名を調べる．そこが，スタート地点
である．

実際には -e オプションは使われず，LD script によってセグメントが分割されて
いることが多い．スタート位置のラベル名がわかったら，あとはおもむろに
grep で探すだけだ．たいていは *start*.s のような名前のアセンブラファイルの
中にある．NetBSD だと locore.s だが，Linux だと start なんちゃらとかいう
ファイルにあるようである(と思ったたしか)．また，スタート位置はアーキテクチャ
依存なので，アーキテクチャごとにディレクトリがわかれているような場合には，
アーキテクチャ依存の部分に入っているはずである．

ブート部分を読む場合には，アセンブラの知識は必須である．C の知識だけでも
読めなくはないが，何をやっているのか，プロセッサはどう動いているのかを
知りたければ，アセンブラを読むしかない．しかし，アセンブラはアセンブラの
文法だけ知っていれば読めるというわけではない．プロセッサに対する知識が絶対に
必要だ．なぜなら，とくにブートストラップやデバイスドライバでは，CPU の
レジスタの設定などを行なうため，

	レジスタの意味がわからなければどうしようもない

からである．

アセンブラに関する資料は，C言語に関する資料に比べれば，残念ながら最近はあまり
多くないように思う．これは，

	本屋に通って必死に探す
	雑誌記事をひたすら探す
	Web 検索でひたすら探す

などして勉強することになる．アセンブラは略語だらけなので，実際のソースだけ
見て勉強するのは辛いと思う．ここで，ひとついい方法がある．クロスコンパイル
環境を作成して，クロスコンパイラで -S オプションでサンプルプログラムを
コンパイルしてみるのだ．このようにすると as を呼び出す直前で中止して，
アセンブラ出力を出してくれる．これを眺めるのだ．Cでやりたいことをアセンブラで
書くとどうなるのか教えてくれるので，実際のところこれはけっこう参考になる．

と，まあ，ここまでいろいろ書いてしまって，まるでここに書いたことが
全部できないとカーネルは読めないみたいになってしまったが，ただ思いつくままに，

	そういえば，あんなこともやったなあ

というレベルで書いただけなので，あまり気にしないでほしい．一番重要なことは，
本人のやる気だ．アセンブラの勉強も含め，カーネルの勉強は短期間でできるものでは
なく，長期的な展望が必要だとおもう．だから，

	来年の今ごろには，読めるようになっているといいなあ

というくらいの余裕を持って，あまり負担をかけずにちまちまとやっていくことが
大事であると思う．

2002/2
(次回作の OMAKE.jpn に続く)

このファイルはここまで．
